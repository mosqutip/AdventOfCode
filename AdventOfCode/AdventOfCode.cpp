#include "AdventOfCode.h"

int main() {
    /***** PROBLEM 1(A-B) *****/
    //string input = "((((()(()(((((((()))(((()((((()())(())()(((()((((((()((()(()(((()(()((())))()((()()())))))))))()((((((())((()))(((((()(((((((((()()))((()(())()((())((()(()))((()))()))()(((((()(((()()))()())((()((((())()())()((((())()(()(()(((()(())(()(())(((((((())()()(((())(()(()(()(())))(()((((())((()))(((()(()()(((((()()(()(((()(((((())()))()((()(()))()((()((((())((((())(()(((())()()(()()()()()(())((((())((())(()()))()((((())))((((()())()((((())((()())((())(())(((((()((((()(((()((((())(()(((()()))()))((((((()((())()())))(((()(()))(()()(()(((()(()))((()()()())((()()()(((())())()())())())((()))(()(()))(((((()(()(())((()(())(())()((((()())()))((((())(())((())())((((()(((())(())((()()((((()((((((()(())()()(()(()()((((()))(())()())()))(())))(())))())()()(())(()))()((()(()(())()()))(()())))))(()))(()()))(())(((((()(()(()()((())()())))))((())())((())(()(())((()))(())(((()((((((((()()()(()))()()(((()))()((()()(())(())())()(()(())))(((((()(())(())(()))))())()))(()))()(()(((((((()((((())))())())())())()((((((((((((((()()((((((()()()())())()())())())(())(())))())((()())((()(()))))))()))))))))))))))))())((())((())()()))))))(((()((()(()()))((())(()()))()()())))(())))))))(()(((())))())()())))()()(())()))()(()))())((()()))))(()))))()))(()()(())))))))()(((()))))()(()))(())())))))()))((()))((()))())(())))))))))((((())()))()))()))())(())()()(())))())))(()())()))((()()(())))(())((((((()(())((()(((()(()()(())))()))))))()))()(()((()))()(()))(()(((())((((())())(())(()))))))))())))))))())())))))())))))()()(((())()(()))))))))())))))(())()()()))()))()))(()(())()()())())))))))())()(()(()))))()()()))))())(()))))()()))))()())))))(((())()()))(()))))))))))()()))))()()()))))(()())())()()())()(()))))()(()))(())))))))(((((())(())())()()))()()))(())))))()(()))))(())(()()))()())()))()))()))()))))())()()))())())))(()))(()))))))())()(((())()))))))))()))()())))())))())))()))))))))))()()))(()()))))))(())()(()))))())(()))))(()))))(()())))))())())()()))))())()))))))))(()))))()))))))()(()())))))))()))())))())))())))())))))))())(()()))))))(()())())))()())()))))))))))))))())))()(())))()))())()()(())(()()))(())))())()())(()(()(()))))())))))))))))())(()))()))()))))(())()())()())))))))))))()()))))))))))))())())))))(()())))))))))))())(())))()))))))))())())(()))()))(())))()))()()(())()))))))()((((())()))())())))))()))()))))((()())()))))())))(())))))))))))))))))()))))()()())()))()()))))())()))((()())))())))(()))(()())))))))()))()))))(())))))))(())))))())()()(()))())()))()()))))())()()))))())()))())))))))(()))))()())()))))))))(()))())))(()))()))))(())()))())())(())())())))))))((((())))))()))()))()())()(())))()))()))()())(()())()()(()())()))))())())))))(()))()))))())(()()(())))))(())()()((())())))))(())(())))))))())))))))))()(())))))))()())())())()(()))))))))(()))))))))())()()))()(()))))))()))))))())))))))(())))()()(())()())))))(((())))()((())()))())))(()()))())(())())))()(((()())))))()(()()())))()()(()()(()()))())()(()()()))())()()))()())(()))))())))))())))(())()()))))(()))))(())(()))(())))))()()))()))))())()))()()(())())))((()))())()))))))()()))))((()(()))))()()))))))())))))())(()((()())))))))))))()())())))()))(()))))))(()))(())()())))(()))))))))())()()()()))))(()())))))))((())))()))(()))(())(())()())()))))))))(())))())))(()))()()))(()()))(()))())))()(())))())((()((()(())))((())))()))))((((())())()())))(())))()))))))())(()()((())))())()(()())))))(()())()))())))))))((())())))))))(()(()))())()()(()()(((()(((()())))))()))))))()(())(()()((()()(())()()))())()())()))()())())())))))))(((())))))))()()))))))(((())()))(()()))(()()))))(()(()()((((())()())((()()))))(()(())))))()((()()()())()()((()((()()))(()))(((()()()))(((())))()(((())()))))))((()(())())))(()())(((((()(()))(()((()))(()())()))))(()(()))()(()))(())(((())(()()))))()()))(((()))))(()()()()))())))((()()()(())()))()))))()()))()))))))((((((()()()))))())((()()(((()))))(()(())(()()())())())))()(((()()))(())((())))(()))(()()()())((())())())(()))))()))()((()(())()(()()(())(()))(())()))(())(()))))(())(())())(()()(()((()()((())))((()))()((())))(((()()()()((((()))(()()))()()()(((())((())())(()()(()()()))()((())(())()))())(((()()(())))()((()()())()())(()(())())(((())(())())((())(())()(((()()))(())))((())(()())())(())((()()()((((((())))((()(((((())()))()))(())(()()))()))(())()()))(())((()()())()()(()))())()((())))()((()()())((((()())((())())())((()((()))()))((())((()()(()((()()(((())(()()))))((()((())()(((())(()((())())((())(()((((((())())()(()())()(())(((())((((((()(())(()((()()()((()()(()()()())))()()(((((()()))()((((((()))()(()(()(()(((()())((()))())()((()))(())))()))()()))())()()))())((((())(()(()))(((((((())(((()(((((()(((()()((((())(((())())))(()()()(()(()))()))((((((()))((()(((()(())((()((((()((((((())(((((())))(((()(()))))(((()(((())()((())(()((()))(((()()(((())((((()(()(((((()))(((()(((((((()(()()()(()(()(()()())(())(((((()(())())()())(()(()(()))()(()()()())(()()(()((()))()((())())()(()))((())(()))()(()))()(((()(()(()((((((()()()()())()(((((()()(((()()()((()(((((()))((((((((()()()(((((()))))))(()()()(())(()))(()()))))(())()))(((((()(((((()()(()(()())(((()))((((()((()(()(()((()(()((())))()(((()((()))((()))(((((((((()((()((()(())))()((((()((()()))((())(((()(((((()()(()(()()((()(()()()(((((((())())()())))))((((()()(()))()))(()((())()(()(((((((((()()(((()(()())(()((()())((())())((((()(((()(((()((((()((()((((()(()((((((())((((((((((((()()(()()((((((((((((((()((()()))()((((((((((((())((((()(()())((()(()(()))()(((((()()(((()()))()())(())((()(((((()((())(((((()((()(((((()))()()((((())()((((())(((((((((()(())(()(())))())(()((())(((())(())(())())(()(()(())()()((()((())()(((()(((((()(())))()(((()((())))((()()()(((()(((()((()(()(())(()((()())(()(()(((()(((((((((())(()((((()()))(()((((()()()()(((()((((((((()(()()((((((()(()()(()((()((((((((((()()(((((((()())(())))(((()()))(((((()((()()())(()()((((())((()((((()))))(())((()(()()(((()(()(((()((((()(((((()))())())(()((())()))(((()())((())((())((((()((()((((((())(()((((()()))((((((())()(()))((()(((())((((((((((()()(((((()(((((()((()()()((((())))(()))()((()(())()()((()((((((((((()((())(())(((((()(()(()()))((((()((((()()((()(((()(((((((((()(()((()((()))((((((()(((())()()((()(((((((()())))()()(()((()((()()(((()(()()()()((((()((())((((()(((((((((()(((()()(((()(()(((()(((()((())()(()((()(()(()(()))()(((()))(()((((()((())((((())((((((())(()))(()((((())((()(()((((((((()()((((((()(()(()()()(())((()((()()(((()(((((((()()((()(((((((()))(((((()(((()(()()()(()(((()((()()((())(()(((((((((()(()((()((((((()()((())()))(((((()((())()())()(((((((((((()))((((()()()()())(()()(()(()()))()))(()))(()(((()()))())(()(()))()()((())(()())()())()(()))()))(()()(()((((((())((()(((((((((((()(())()((()(()((()((()(()((()((((((((((()()())((())()(())))((())()())()(((((()(()())((((()((()(())(()))(((())()((()))(((((())(()))()()(()))(((())((((()((((()(())))(((((((()))))())()())(())((())()(()()((()(()))()(()()(()()((()())((())((()()))((((()))()()))(()()(())()()(((((()(())((()((((()))()))(()())())(((()()(()()))(())))))(()))((())(((((()((((()))()((((()))()((())(((())))(((()())))((()(()()((";
    //cout << "Santa is on floor: " << DetermineFloor(input) << "." << endl;
    //cout << "The first basement floor is at position: " << DetermineFirstBasementFloorPosition(input) << "." <<endl;
    /***** PROBLEM 1(A-B) *****/


    /***** PROBLEM 2(A-B) *****/
    //cout << "Total wrapping paper area is: " << TotalWrappingPaperArea("Files\\Day2.txt") << " square feet." << endl;
    //cout << "Total ribbon length area is: " << TotalRibbonLength("Files\\Day2.txt") << " feet." << endl;
    /***** PROBLEM 2(A-B) *****/


    /***** PROBLEM 3(A-B) *****/
    //cout << "Total houses visited: " << VisitedHouseCount("Files\\Day3.txt") << endl;
    //cout << "Total houses visited: " << VisitedHouseCounts("Files\\Day3.txt") << endl;
    /***** PROBLEM 3(A-B) *****/


    /***** PROBLEM 3(A-B) *****/
    //cout << "The lowest integer that produces a valid hash is: " << GenerateHash("ckczppom", 5) << endl;
    //cout << "The lowest integer that produces a valid hash is: " << GenerateHash("ckczppom", 6) << endl;
    /***** PROBLEM 3(A-B) *****/


    /***** PROBLEM 3(A-B) *****/
    cout << "The number of nice strings is: " << CountNiceStrings("Files\\Day5.txt") << endl;
    /***** PROBLEM 3(A-B) *****/
}

int DetermineFloor(string input) {
    int count = 0;

    for (size_t i = 0; i < input.size(); ++i) {
        if (input[i] == '(') {
            ++count;
        }
        else if (input[i] == ')') {
            --count;
        }
    }

    return count;
}

int DetermineFirstBasementFloorPosition(string input) {
    int count = 0;

    for (size_t i = 0; i < input.size(); ++i) {
        if (input[i] == '(') {
            ++count;
        }
        else if (input[i] == ')') {
            --count;
        }

        if (count < 0) {
            return (i + 1);
        }
    }

    return count;
}

int TotalWrappingPaperArea(string filename) {
    string line;
    ifstream file(filename);
    vector<string> tokens(3, "");
    int area = 0;

    if (file.is_open())
    {
        while (getline(file, line))
        {
            split(line, 'x', tokens);
            area += WrappingPaperArea(stoi(tokens[0]), stoi(tokens[1]), stoi(tokens[2]));
        }

        file.close();
    }

    return area;
}

int WrappingPaperArea(int l, int w, int h) {
    int area = (2 * ((l * w) + (w * h) + (h * l)));
    area += (minProduct(l, w, h));

    return area;
}

int TotalRibbonLength(string filename) {
    string line;
    ifstream file(filename);
    vector<string> tokens(3, "");
    int length = 0;

    if (file.is_open())
    {
        while (getline(file, line))
        {
            split(line, 'x', tokens);
            length += RibbonLength(stoi(tokens[0]), stoi(tokens[1]), stoi(tokens[2]));
        }

        file.close();
    }

    return length;
}

int RibbonLength(int l, int w, int h) {
    int length = (l * w * h);
    length += (2 * minSum(l, w, h));

    return length;
}

vector<string> &split(const std::string &s, char delim, vector<string> &elems) {
    stringstream stringStream(s);
    string item;
    int index = 0;

    while (getline(stringStream, item, delim)) {
        elems[index] = item;
        ++index;
    }

    return elems;
}

int minProduct(int a, int b, int c) {
    int max = a;

    if (max < b) {
        max = b;
    }
    if (max < c) {
        max = c;
    }

    return ((a * b * c) / max);
}

int minSum(int a, int b, int c) {
    int max = a;

    if (max < b) {
        max = b;
    }
    if (max < c) {
        max = c;
    }

    return (-max + (a + b + c));
}

int VisitedHouseCount(string filename) {
    ifstream file(filename);
    set<string> visited;
    int x = 0, y = 0, visitedCount = 1;
    string coords = "0,0";

    visited.emplace(coords);

    if (file.is_open())
    {
        char c;

        while (file.get(c))
        {
            coords = SetNewCoordinates(x, y, c);

            if (visited.emplace(coords).second) {
                ++visitedCount;
            }
        }

        file.close();
    }

    return visitedCount;
}

int VisitedHouseCounts(string filename) {
    ifstream file(filename);
    set<string> visited;
    bool turn = true;
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, visitedCount = 1;
    string coords = "0,0";

    visited.emplace(coords);

    if (file.is_open())
    {
        char c;

        while (file.get(c))
        {
            if (turn) {
                coords = SetNewCoordinates(x1, y1, c);
            }
            else {
                coords = SetNewCoordinates(x2, y2, c);
            }

            if (visited.emplace(coords).second) {
                ++visitedCount;
            }

            turn = !turn;
        }

        file.close();
    }

    return visitedCount;
}

string SetNewCoordinates(int &x, int &y, const char c) {
    switch (c) {
    case '>':
        ++x;
        break;
    case '^':
        ++y;
        break;
    case '<':
        --x;
        break;
    case 'v':
        --y;
        break;
    }

    return to_string(x) + "," + to_string(y);
}

int GenerateHash(string input, int zeroes) {
    int x = 1;
    string s, result;
    char *compare = (zeroes == 5) ? "00000" : "000000";

    while (true) {
        s = input + to_string(x);
        result = md5(s);

        if (strncmp(result.c_str(), compare, zeroes) == 0) {
            return x;
        }

        ++x;
    }
}

int CountNiceStrings(const string filename) {
    string line;
    ifstream file(filename);
    int count = 0;

    if (file.is_open())
    {
        while (getline(file, line))
        {
            if (IsNiceString(line)) {
                ++count;
            }
        }

        file.close();
    }

    return count;
}

bool IsNiceString(const string s) {
    char prev = s[0], cur;
    int vowelCount = (IsVowel(prev) ? 1 : 0);
    bool hasDouble = false;

    for (int i = 1; i < s.size(); ++i) {
        cur = s[i];

        if (cur == prev) {
            hasDouble = true;
        }

        if (IsVowel(s[i])) {
            ++vowelCount;
        }

        if (IsBadDuo(prev, cur)) {
            return false;
        }

        prev = cur;
    }

    if (hasDouble && (vowelCount >= 3)) {
        return true;
    }

    return false;
}

bool IsBadDuo(const char c1, const char c2) {
    if (((c1 == 'a') && (c2 == 'b')) ||
        ((c1 == 'c') && (c2 == 'd')) ||
        ((c1 == 'p') && (c2 == 'q')) ||
        ((c1 == 'x') && (c2 == 'y')))
    {
        return true;
    }

    return false;
}

bool IsVowel(const char c) {
    switch (c) {
        case 'a':
            return true;
        case 'e':
            return true;
        case 'i':
            return true;
        case 'o':
            return true;
        case 'u':
            return true;
        default:
            return false;
    }
}